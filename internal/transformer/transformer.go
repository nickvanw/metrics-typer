package transformer

import (
	"log"
	"strings"

	"github.com/nickvanw/metrics-typer/internal/config"
	promproto "github.com/nickvanw/metrics-typer/internal/proto"
)

type Transformer struct{}

func New() *Transformer {
	return &Transformer{}
}

// Transform modifies metrics based on config rules and ensures configured metrics have metadata
func (t *Transformer) Transform(req *promproto.WriteRequest) {
	if len(req.Timeseries) == 0 {
		log.Printf("No timeseries to transform")
		return
	}

	// Track configured metrics that need metadata
	configuredMetricsNeedingMetadata := make(map[string]string) // base name -> type

	// Find all unique configured metrics in the timeseries
	for _, ts := range req.Timeseries {
		// Extract metric name from labels
		var metricName string
		for _, label := range ts.Labels {
			if label.Name == "__name__" {
				metricName = label.Value
				break
			}
		}
		if metricName == "" {
			continue
		}

		// Get base name by removing suffixes (_bucket, _sum, _count)
		baseName := getBaseMetricName(metricName)

		// Check if this is a configured metric (in MetricTypeMap)
		for pattern, typeStr := range config.MetricTypeMap {
			if strings.Contains(baseName, pattern) {
				configuredMetricsNeedingMetadata[baseName] = typeStr
				break
			}
		}
	}

	log.Printf("Found %d configured metrics that may need metadata", len(configuredMetricsNeedingMetadata))

	// First update existing metadata and track which metrics already have metadata
	var updatedCount int
	existingMetadataNames := make(map[string]bool)

	for i, metadata := range req.Metadata {
		metricName := metadata.MetricFamilyName
		if metricName == "" {
			continue
		}

		// Mark this metric as having metadata
		existingMetadataNames[metricName] = true

		// Check if this is a configured metric
		var typeToUse string
		for pattern, typeStr := range config.MetricTypeMap {
			if strings.Contains(metricName, pattern) {
				typeToUse = typeStr
				break
			}
		}

		// Skip if not a configured metric
		if typeToUse == "" {
			continue
		}

		// Update type if needed
		originalType := metadata.Type.String()
		if originalType != strings.ToUpper(typeToUse) {
			t.setMetricType(req.Metadata[i], typeToUse)
			log.Printf("UPDATED: metric=%s: %s â†’ %s",
				metricName, originalType, strings.ToUpper(typeToUse))
			updatedCount++
		}
	}

	// Remove metrics that already have metadata
	for metricName := range existingMetadataNames {
		delete(configuredMetricsNeedingMetadata, metricName)
	}

	// Create metadata for configured metrics that need it
	var createdCount int
	for metricName, typeStr := range configuredMetricsNeedingMetadata {
		newMetadata := &promproto.MetricMetadata{
			MetricFamilyName: metricName,
			Help:             "Automatically generated by metrics-transformer",
		}
		t.setMetricType(newMetadata, typeStr)
		req.Metadata = append(req.Metadata, newMetadata)
		log.Printf("CREATED: new metadata for metric=%s with type=%s", metricName, strings.ToUpper(typeStr))
		createdCount++
	}

	log.Printf("SUMMARY: Created %d new metadata entries, updated %d existing entries",
		createdCount, updatedCount)
	log.Printf("AFTER: len(timeseries)=%d, len(metadata)=%d", len(req.Timeseries), len(req.Metadata))
}

// getBaseMetricName returns the base name for a metric, removing _bucket, _sum, _count suffixes
func getBaseMetricName(metricName string) string {
	if strings.HasSuffix(metricName, "_bucket") {
		return strings.TrimSuffix(metricName, "_bucket")
	} else if strings.HasSuffix(metricName, "_sum") {
		return strings.TrimSuffix(metricName, "_sum")
	} else if strings.HasSuffix(metricName, "_count") {
		return strings.TrimSuffix(metricName, "_count")
	}
	return metricName
}

// setMetricType changes the metric type based on the string type name
func (t *Transformer) setMetricType(metadata *promproto.MetricMetadata, newType string) {
	switch strings.ToUpper(newType) {
	case "COUNTER":
		metadata.Type = promproto.MetricMetadata_COUNTER
	case "GAUGE":
		metadata.Type = promproto.MetricMetadata_GAUGE
	case "HISTOGRAM":
		metadata.Type = promproto.MetricMetadata_HISTOGRAM
	case "GAUGEHISTOGRAM":
		metadata.Type = promproto.MetricMetadata_GAUGEHISTOGRAM
	case "SUMMARY":
		metadata.Type = promproto.MetricMetadata_SUMMARY
	case "INFO":
		metadata.Type = promproto.MetricMetadata_INFO
	case "STATESET":
		metadata.Type = promproto.MetricMetadata_STATESET
	default:
		metadata.Type = promproto.MetricMetadata_UNKNOWN
	}
}
